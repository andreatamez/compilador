// Andrea Tamez A01176494
//MEMYSELF

/* Estos son los includes para que el codigo c# que agregue funcione correctamente */
using System.Collections; // esto incluye las listas y diccionarios
using System.Collections.Generic; // listas y diccionarios pero soporta genericas que significa tener una lista de ints o string
using System.Linq; // incluye las librerias que permite ling support

/*PG 35 en User Manual Taste.ATG ejemplo */
/* Aqui es donde comienza el codigo de COCO */
COMPILER MeMySelf

//Empieza C#
    //Todo lo que esta aqui adentro es codigo C# y este es cosas que Coco toma este codigo y lo pone en la autogenerated file sin cambios.

    public string progName;

    private const string IntReturnFunc = "__intReturn";
    private const string FloatReturnFunc = "__floatReturn";
    private const string CharReturnFunc = "__charReturn";

    public CodeGenerator codegen;

    public CuboSemantico cuboSemantico;
    public bool DebugMode;

    private Stack<Op> pOper = new Stack<Op>();
    private Stack<MyType> pilaType = new Stack<MyType>();
    private Stack<int> pilaOp = new Stack<int>(); //Operador
    private Stack<int> pSaltos = new Stack<int>(); //pila Saltos para llenar el quad

    /*Cuadruplos */
    /*Lo que hace esta funcion es que al momento en que llaman verifica que el orden de operaciones
    este correcto para crear un cuadruplo 
    
    ej. voy a hacer una multiplicacion y verifica que si funcione bien 

    5 * 6 * 7...

    pilaOp = 5,6
    pOper = *,*

    ahora que hay un * mas checa AddQuad con *,/ que son el mismo orden de operaciones
    entonces ahora llama esto y ahora checa okey hay un * o division y si si hay ahora 
    toma lo que hay en la pilaOp lo toma y lo guarda en t1 y crea ese cuadruplo y pushea t1 
    a la stack

    pilaOp = t1
    pOper = ...
    
    */
    public void CheckAndAddQuad(params Op[] ops)
    {
        Op peekOp = pOper.Count == 0 ? Op.EMPTY : pOper.Peek();
        if(ops.Any(op => op.Equals(peekOp)) && pilaOp.Count >= 2)
        {
            if (DebugMode) Console.Out.WriteLine($"peekOp={peekOp}, pOper.Count={pOper.Count}, pilaOp.Count={pilaOp.Count}, pilaType.Count={pilaType.Count}");
            Op op = pOper.Pop();
            int oper_der = pilaOp.Pop();
            int oper_izq = pilaOp.Pop();

            MyType tipo_der = pilaType.Pop();
            MyType tipo_izq = pilaType.Pop();

            MyType tipo_out = cuboSemantico.GetType(op, tipo_izq, tipo_der);
            if (tipo_out == MyType.error)
            {
                SemErr($"Type mismatch. op={op}, tipo_izq={tipo_izq}, tipo_der={tipo_der}");
            }

            int registro = codegen.NextRegister(tipo_out);
            codegen.AddQuad(op, oper_izq, oper_der, registro);

            pilaOp.Push(registro);
            pilaType.Push(tipo_out);
        }
    }

    /*Asignacion = checo el siguiente caracter a ver si es equals  */
    public bool IsAsignacion()
    {
        Token next = scanner.Peek();
        return la.kind == _id && next.val == "=";
    }

    /*Parametro */
    public bool IsParam()
    {
        Token next = scanner.Peek();
        return la.kind == _id && next.val == ":";
    }

    /*Declaracion de Variable */
    public bool IsVarDeclaration()
    {
        Token next = scanner.Peek();
        return next.val == ":";
    }

/**********************/
    /* NO ESTA COMPLETA AUN funciones especiales para graficas*/
    public void InitFuncionesEspeciales()
    {
        VarTable emptyLocals = codegen.GetEmptyTable();

        VarTable lineFuncParams = codegen.GetEmptyTable();
        // lineFuncParams.AddData(new VarRow())
        // FuncRow lineFunc = new FuncRow("LINE", MyType.undef, 0, )
    }

/**********************/

/*2.3.1 */
CHARACTERS /* Estos son para definir los tokens */
    letter = 'A'..'Z' + 'a'..'z'. /*Letras */
    digit = '0'..'9'. /*Numeros */
    noCero = '1'..'9'. /*Todo excepto 0 */
    noQuote = ANY - '"'. /*Palabras */
    noSingleQuote = ANY - '\''.

/*2.3.2 terminal symbols end result of a grammar production matching de los numeros que utilizas
para saber si es int, float, char */
TOKENS /* Int, Float y Char */

/* [0-1 time]*/

    /* Constante Int Esto define como se ve un const integer, puedes tener un signo negativo o no puede ser 0 o cualquier 
    numero despues */
    cte_i = ['-'] ('0' | (noCero {digit})). 

    /* Constante Float hay 3 definiciones el primero es un numero y luego un numero decimal y es todo y el siguiente puede ser 4. o .4 o 0.4 */
    cte_f = ['-'] ((('0' | (noCero {digit})) '.') 
    | ('.' ('0' | (noCero {digit}))) 
    | (('0' | (noCero {digit})) '.'  ('0' | (noCero {digit})))). 

    /* Constante Char no pudedes tener un caracter de un ' */
    cte_c = '\'' noSingleQuote '\''. /* Contsante Char */

    /* id es primero debe tener una letra para empezar y luego ya agregar numeros o letras 0 o mas veces */
    id = letter {letter | digit}.

    /* noQuote letras y mas no queria implementar con ' adentro es muy complicado  */
    letrero = '"' {noQuote} '"'.

COMMENTS FROM "%*" TO "*%" NESTED
COMMENTS FROM "%%" TO '\n'

IGNORE '\r' + '\n' + '\t'

PRODUCTIONS /*Es donde empiezo las reglas de gramatica */

/*MeMyself es donde comienzas la declaracionla estructura general y el nombre aqui necesita ser el mismo que del compilador en el 
nombre amero arriba

Aqui empieza a matchear.

*/
MeMySelf

/*program Andrea(id) */
                                    (.  VarTable table = codegen.GetEmptyTable(); .)      
    = ("Program" | "program") id            (.  progName = t.val; /*Andrea */
                                                int count = codegen.AddQuad(Op.GOTO, -1, -1, -1); /*GOTO */
                                                pSaltos.Push(count); /*pSaltos agregamos el 0 */
                                                 .)
    ';'
    /*Opcional definicion de variables y siempre empieza con var -> var int : i, j; si no hubiera variables ahora continuaria
    al main */
    [DefinicionDeVariables<out table>]
                                            (.  table.AddData(new VarRow(IntReturnFunc, MyType.intType, 0));
                                                table.AddData(new VarRow(FloatReturnFunc, MyType.floatType, 0));
                                                table.AddData(new VarRow(CharReturnFunc, MyType.charType, 0));
                                                FuncRow prog = codegen.funcTable.NewFuncRow(progName, MyType.undef, 0, table, codegen.GetEmptyTable()); // new FuncRow(progName, MyType.undef, 0, table, codegen.GetEmptyTable());
                                                /*estas son para cuando la gente va retornar custom global variables
                                                para que yo pueda hacer returns funcionar para asignarle esa variable
                                                y se utiliza porque sino no hay manera de regresar de funciones. */
                                                /*Aqui asignamos la tabla con los datos */
                                                codegen.AddFunction(prog);
                                                codegen.SetGlobalTable(table);
                                                 .)
    {DefinicionDeFuncion}
    "main()"
    '{'
                                            (.  int jumpLoc = codegen.Cont(); 
                                                int gotoOp = pSaltos.Pop();
                                                codegen.Fill(gotoOp, jumpLoc);
                                                prog.localVars.UpdateStartAddress(codegen.funcTable.addressNext);
                                                codegen.SetCurrentScopeTable(prog.localVars); .)
        [Estatutos]
                                            (.  codegen.funcTable.UpdateAddressNext(prog.localVars); .)
    '}'
    .

/*Esta es la definicion que viene en el documento del proyecto de Declaracion de Variables
Lado Izq es Coco Lado derecho es C# */
DefinicionDeVariables<out VarTable table>               (. MyType type; List<VarRow> list; table = codegen.GetEmptyTable(); .)
    =
        /*Esto es la misma definicion de memysel var %%palabra reservada
                                                    tipo : lista_ids;
                                si son mas          <tipo : lista_ids;> etc 
        ahora una vez que ya tenemos el tipo ahora el var ya le regresa el tipo exacto que se le asingo.
        
        var int : i;
        se va a tipo y dice hace match con int ahora asigna al type myType.intType y le regresa ese tipo
        y ahor el colon hace matching y checa el lista ids y se va a lista_ids y checa
        primero que i sea un id checa con el matching que teniamos arriba 
        tomo el token del id y lo agrego a mi string list donde se guardan todos los ids
        */
        /*Ahora aqui ya despues de ver el var int i,j checa que diga var y ahora checa el tipo.
        type ahora tiene int
        ahora vemos si i matchea a lista ids

       Aqui regresamos la lista 
         */
        "var" tipo<out type> ':' lista_ids<ref type, out list> ';'
                                                            (.  foreach (var row in list)
                                                                {
                                                                    //esto se puede ver en symbol table donde le damos un nombre type and size
                                                                    table.AddData(row);
                                                                } .)
        {
        /*Para representar si hay mas de uno de esete aqui es donde se crea el loop. */
            IF(IsVarDeclaration())
            tipo<out type> ':' lista_ids<ref type, out list> ';'
                                                            (.  foreach (var row in list)
                                                                {
                                                                    table.AddData(row);
                                                                } .)
        }
        .

/* Aqui es donde se define lo que es tipo y es declaro que solo puede ser int, float o char
out significa que regresa el tipo que le asignaste abajo ya sea int, float o char */
/*Int si existe  */
tipo<out MyType type>   (. type = MyType.error; .)
    =
        "int"       (. type = MyType.intType; .)  
        | "float"   (. type = MyType.floatType; .)
        | "char"    (. type = MyType.charType; .)
        .

/* Aqui es donde defino lo que es lista_ids puede ser un id que puede igual tener varios o solo 1*/
/*i matchea con id y ahora leemos i y j */
lista_ids<.ref MyType type, out List<VarRow> rows .>
    =
    /*Agrega la lista de iDS que tenemos en el codigo */
                            (.  rows = new List<VarRow>(); VarArray varArray = null; string idName; .)
        id                  (.  idName = t.val; .)
        [
            ArrayDeclaration<ref idName, ref type, out varArray>
                            (.  rows.Add(varArray); .)
        ]
                            (.  if (varArray == null)
                                {
                                    rows.Add(new VarRow(idName, type, 0));
                                }

                                varArray = null;
                            .)
        {
            ',' id              (.  idName = t.val; .)
            [
                ArrayDeclaration<ref idName, ref type, out varArray>
                                (.  rows.Add(varArray); .)
            ]
                                (.  if (varArray == null)
                                    {
                                        rows.Add(new VarRow(idName, type, 0));
                                    }

                                    varArray = null;
                                .)
        }
        .

ArrayDeclaration<ref string idName, ref MyType type, out VarArray varArray> =
                                            (.  List<int> dims = new List<int>(); string low, high; int lowI, highI; varArray = null; .)
        '['
            cte_i                           (.  low = t.val; high = null; .)
            [
                ".."
                cte_i                       (.  high = t.val; .)
            ]
        ']'
                                            (.  if (!int.TryParse(low, out lowI))
                                                {
                                                    SemErr($"arrays necesita int: {low}");
                                                    return;
                                                }

                                                if (high == null)
                                                {
                                                    high = (lowI - 1).ToString();
                                                    lowI = 0;
                                                }

                                                if (!int.TryParse(high, out highI))
                                                {
                                                    SemErr($"arrays necesita int: {high}");
                                                    return;
                                                }

                                                dims.Add(lowI);
                                                dims.Add(highI);
                                            
                                            .)
    {
        '['
            cte_i                           (.  low = t.val; high = null; .)
            [
                ".."
                cte_i                       (.  high = t.val; .)
            ]
        ']'
                                            (.  if (!int.TryParse(low, out lowI))
                                                {
                                                    SemErr($"arrays necesita int: {low}");
                                                    return;
                                                }

                                                if (high == null)
                                                {
                                                    high = (lowI - 1).ToString();
                                                    lowI = 0;
                                                }

                                                if (!int.TryParse(high, out highI))
                                                {
                                                    SemErr($"arrays necesita int: {high}");
                                                    return;
                                                }

                                                dims.Add(lowI);
                                                dims.Add(highI);
                                            
                                            .)
    }
                                            (. varArray = new VarArray(idName, type, 0, dims.ToArray()); .)
    .

/*Aqui empiezas con las funciones */
DefinicionDeFuncion             (. MyType type = MyType.undef; VarTable parameters, localVars; .)
    =
        /*tipo retorno si no tiene nombre se hace void*/
        [tipo_retorno<out type>] "module" id    (.  string funcName = t.val;
                                                    parameters = codegen.GetEmptyTable();
                                                    localVars = codegen.GetEmptyTable(); .)
        '('
            /*Parametros esta declarado abajo y es respecto a var_simple en donde se pone un tipo y luego el id (nombre) */
            [Parametros<out parameters>]
        ')'
        /* ';' */
        /*No agregue el semicolon porque no me gustaba como se veia */

        /*Esta se refiere a la gramatica de arriba de definicion de variables tipo: var int : hello1 */
        [DefinicionDeVariables<out localVars>]
                                                (.  int curQuad = codegen.Cont(); /*current quad en el que estamos */
                                                    FuncRow row = codegen.funcTable.NewFuncRow(funcName, type, curQuad, parameters, localVars); // new FuncRow(funcName, type, curQuad, parameters, localVars);
                                                    /*Currentscope son las local variables para cualquier seccion en la que estemos */
                                                    codegen.AddFunction(row);
                                                    codegen.SetCurrentScopeParamsTable(parameters);
                                                    codegen.SetCurrentScopeTable(localVars); .)
        '{'
            [Estatutos]
        '}'
                                                (.  codegen.UpdateFuncTableAddressing(localVars);
                                                    codegen.ResetCurrentScopeTable();
                                                    codegen.AddQuad(Op.ENDFUNC, -1, -1, -1); .)
        .

Parametros<out VarTable parameters>             (. parameters = codegen.GetEmptyTable(); VarRow row; .)
 =  var_simple<out row>                         (. parameters.AddData(row); .)
    {
        ',' var_simple<out row>                 (. parameters.AddData(row); .)
    }.

/*int hola2 */
var_simple<out VarRow row>                  (. MyType type; .)
    = tipo<out type> 
        id  (. row = new VarRow(t.val, type, 0); .)
        .

/*si no tiene ningun tipo se le asigna void */
tipo_retorno<out MyType type>           (. type = MyType.error; .)
    = "void"                            (. type = MyType.undef; .)
    | tipo<out type>
    .

/* i =5;
while (i >) etc.. */
Estatutos = Estatuto {Estatuto}.

/*Diferentes tipos de estatutos */
Estatuto  (. MyType type; .)
    = IF(IsAsignacion()) Asignacion /*Aqui verifico que si sea una asignacion y no una funcion con el mismo nombre o algo asi */
        | LlamadaAVoid | RetornoDeFuncion<out type> | Lectura | Escritura | EstatutoDeDecision | Condicional_Rep | NoCondicional_Rep.

/*id = expresion */
//Si no funciona te va decir tipo invalido.
Asignacion = (. MyType type; VarArray arrayVar = null; int derefAddr = -1; .)
    id
                                (.  VarRow row = codegen.GetVar(t.val); .)
    [
                                
        ArrayIndexing<ref arrayVar, out derefAddr>
    ]
    '='
    (
        Expresion<out type>
                                                        (.  
                                                            type = pilaType.Pop();
                                                            var exp = pilaOp.Pop();
                                                            //verifica que si asignas entre estas cosas cual es el outType
                                                            MyType tipo_out = cuboSemantico.GetType(Op.SET, row.type, type);
                                                            if (tipo_out == MyType.error)
                                                            {
                                                                SemErr("tipo invalido");
                                                            }

                                                            codegen.AddQuad(Op.SET, exp, -1, row.address);
                                                        .)
    )
    ';'
    .

/* hola2(); hola(3); hola2(hey2); */
LlamadaAVoid =
    id                                      (.  FuncRow row = codegen.GetFunction(t.val);
                                                codegen.AddQuad(Op.ERA, row.address, -1, -1);    .)
    '('
        [ParametrosConValores<ref row>]
    ')'
                                            (. codegen.AddQuad(Op.GOSUB, -1, -1, row.address); .)
    ';'. 
    
/*Aqui es donde paso la lista de parametros y el nombre cuando lo paso
ej. f3(i, b: i+5)
lo agregue porque queria que el compiler soportara nombrar a los parametros para que fuera mas claro
es opcional poner el nombre tipo b: i+5 y esto sirve para guiar y que el programador no se confunda cuando
haga el codigo
*/
ParametrosConValores<ref FuncRow row> = (.  MyType type; int exp; VarRow rowCmp;
                                            List<VarRow> parameters = row.parameters.GetDataList();
                                            int counter = 0;
                                            string idName = null;
                                            bool needsIdLabel = false;
                                            bool hasIdLabel = false;        .)
    [
        IF(IsParam())
        id                                  (. hasIdLabel = true; needsIdLabel = true; idName = t.val; .)
        ':'
    ]
    Expresion<out type>
                                            (.  type = pilaType.Pop();
                                                exp = pilaOp.Pop();
                                                rowCmp = parameters[counter];
                                                if (hasIdLabel && !rowCmp.name.Equals(idName))
                                                {
                                                    SemErr($"calling func={row.name}, id={idName} does not match {rowCmp.name}, pos {counter}");
                                                }

                                                if (rowCmp.type != type)
                                                {
                                                    SemErr($"calling func={row.name}, in type {type} does not match expected type {rowCmp.type}");
                                                }

                                                codegen.AddQuad(Op.PARAMETER, exp, row.address, counter);
                                                counter += 1;

                                                hasIdLabel = false;
                                                idName = null; .)
    {
        ','
        [
            IF(IsParam())
            id                              (. hasIdLabel = true; needsIdLabel = true; idName = t.val; .)
            ':'
        ]
                                        (.  if (needsIdLabel && !hasIdLabel)
                                            {
                                               SemErr($"Need id label after having id label."); 
                                            }.)
        Expresion<out type>
                                            (.  type = pilaType.Pop();
                                                exp = pilaOp.Pop();
                                                rowCmp = parameters[counter];
                                                if (hasIdLabel && !rowCmp.name.Equals(idName))
                                                {
                                                    SemErr($"calling func={row.name}, id={idName} does not match {rowCmp.name}, pos {counter}");
                                                }

                                                if (rowCmp.type != type)
                                                {
                                                    SemErr($"calling func={row.name}, in type {type} does not match expected type {rowCmp.type}");
                                                }

                                                codegen.AddQuad(Op.PARAMETER, exp, row.address, counter);
                                                counter += 1;

                                                hasIdLabel = false;
                                                idName = null; .)
    }
                                            (.  if (counter != parameters.Count)
                                                {
                                                    SemErr($"calling func={row.name}, incorrect number of parameters");
                                                }.)
    .

/* puede ser return(b); o podemos tambien poner return(f1(a) + f1(2)); */
RetornoDeFuncion<out MyType type> =
    "return"
    '('
        Expresion<out type>
                                (.  type = pilaType.Pop();
                                    int exp = pilaOp.Pop();
                                    string retName = null;
                                    switch (type)
                                    {
                                        case MyType.intType:
                                            retName = IntReturnFunc;
                                            break;
                                        case MyType.floatType:
                                            retName = FloatReturnFunc;
                                            break;
                                        case MyType.charType:
                                            retName = CharReturnFunc;
                                            break;
                                        default:
                                            SemErr($"Tipo invalido: {type}");
                                            break;
                                    }

                                    var row = codegen.GetVar(retName);

                                    codegen.AddQuad(Op.RETURN, exp, row.address, -1); .)
    ')'
    ';'.

/*  read significa que reciben el valor read(p); tambien puedes leer varias y diriar read(p,r,u);*/
Lectura = (. VarRow row; .)
    "read"
    '('
        id          (.  row = codegen.GetVar(t.val);
                        if (row.IsArray)
                        {
                            SemErr($"{t.val} es array, no puede leer");
                            return;
                        }
                        codegen.AddQuad(Op.READ, row.address, -1, -1); .)
        {
            ','
            id      (.  row = codegen.GetVar(t.val);
                        if (row.IsArray)
                        {
                            SemErr($"{t.val} es array, no puede leer");
                            return;
                        }
                        codegen.AddQuad(Op.READ, row.address, -1, -1); .)
        }
    ')'
    ';'
    .

/* escritura es para imprimir igual que read pones la lista de expresiones que quieres mostrar write(h,q,a) write("Hello"); */
Escritura = (. MyType type; int exp; MyType unusedType; .)
    "write"
    '('
        Expresion<out type>
                                    (.
                                        exp = pilaOp.Pop();
                                        unusedType = pilaType.Pop();
                                        codegen.AddQuad(Op.WRITE, exp, -1, -1);
                                    .)
        {
            ','
            Expresion<out type>
                                    (.
                                        exp = pilaOp.Pop();
                                        unusedType = pilaType.Pop();
                                        codegen.AddQuad(Op.WRITE, exp, -1, -1);
                                    .)
        }
    ')'
    ';'
    .
/*estatutos como if then(not opcional) else(opcional)  */
EstatutoDeDecision = (. MyType type; .)
    "if"
    '('
        Expresion<out type>     (.  if (type != MyType.intType)
                                    {
                                        SemErr("Requiere expresion condicional (intType)");
                                    }

                                    pilaType.Pop();
                                    int exp = pilaOp.Pop();
                                    int quadNum = codegen.AddQuad(Op.GOTOF, exp, -1, -1);
                                    pSaltos.Push(quadNum);
                                .)
    ')'
    "then"
    '{'
        [Estatutos]
                                (.  int endIf = codegen.AddQuad(Op.GOTO, -1, -1, -1);
                                    int jumpLine = pSaltos.Pop();
                                    codegen.Fill(jumpLine, endIf + 1);
                                    pSaltos.Push(endIf);
                                .)
    '}'
    [
        "else"
        '{'
        [Estatutos]
        '}'
    ]
                                (.  int nextQuad = codegen.Cont();
                                    int endIf2 = pSaltos.Pop();
                                    codegen.Fill(endIf2, nextQuad);
                                .)
    .

/* Loop de while while(i > 0)() do {i = i+5}; */
Condicional_Rep = (. MyType type; .)
    "while"
    '('
                            (. pSaltos.Push(codegen.Cont()); .)
        Expresion<out type>
                        (.  MyType expType = pilaType.Pop();
                            if (expType != MyType.intType)
                            {
                                 SemErr("Requiere expresion condicional (intType)");
                            }

                            int exp = pilaOp.Pop();
                            int jumpQuad = codegen.AddQuad(Op.GOTOF, exp, -1, -1);
                            pSaltos.Push(jumpQuad); .)
    ')'
    "do"
    '{'
        [Estatutos]
                            (.  int jumpQuad2 = pSaltos.Pop(); 
                                int cicloEmpieza = pSaltos.Pop(); 
                                int skipQuad = codegen.AddQuad(Op.GOTO, -1, -1, cicloEmpieza);
                                codegen.Fill(jumpQuad2, skipQuad); .)
    '}'
    ';'
    .

/*for loop en el que usamos from en vez de for from i=0 to 9 do { i = i+4 };  */
NoCondicional_Rep = (. MyType type; .)
    "from"
    id              (.  VarRow iter = codegen.GetVar(t.val);
                        if (iter.type != MyType.intType || iter.IsArray)
                        {
                            SemErr($"Requiere expresion intType, pero {t.val} es {iter.type},IsArray:{iter.IsArray}");
                        }
                        .)
    '='
    Expresion<out type>
                    (.  type = pilaType.Pop();
                        int exp = pilaOp.Pop();
                        if (type != MyType.intType)
                        {
                            SemErr($"Requiere expresion intType, pero {exp} es {type}");
                        }

                        codegen.AddQuad(Op.SET, exp, -1, iter.address);
                        
                        .)
    "to"
    Expresion<out type>
                    (.  type = pilaType.Pop();
                        exp = pilaOp.Pop();
                        if (type != MyType.intType)
                        {
                            SemErr($"Requiere expresion intType, pero {exp} es {type}");
                        }

                        int terminaReg = codegen.NextRegister(type);
                        codegen.AddQuad(Op.SET, exp, -1, terminaReg);
                        
                        int cmpReg = codegen.NextRegister(MyType.intType);
                        int cmpQuad = codegen.AddQuad(Op.LTE, iter.address, terminaReg, cmpReg);
                        int jumpQuad = codegen.AddQuad(Op.GOTOF, cmpReg, -1, -1);
                        pSaltos.Push(cmpQuad);
                        pSaltos.Push(jumpQuad);
                    .)
    "do"
    '{'
        [Estatutos]
    '}'
                    (.  int cnstAddress = codegen.AddConstanteInt("1");
                        codegen.AddQuad(Op.ADD, cnstAddress, iter.address, iter.address);
                        jumpQuad = pSaltos.Pop();
                        cmpQuad = pSaltos.Pop();
                        codegen.AddQuad(Op.GOTO, -1, -1, cmpQuad);

                        int nextQuad = codegen.Cont();
                        codegen.Fill(jumpQuad, nextQuad);
                    .)
    .

ArrayIndexing<ref VarArray varArray, out int refAddress> = (. MyType type; int counter = 0, constAddr; int reg = codegen.NextRegister(MyType.intType); .)

        '['
                                        (.  if (counter == varArray.dimensionSizes.Length)
                                            {
                                                SemErr($"Invalid tamano(grande): {counter}");
                                            }
                                        .)
            Expresion<out type>
                                        (.  type = pilaType.Pop(); 
                                            int exp = pilaOp.Pop();
                                            if (type != MyType.intType)
                                            {
                                                SemErr($"Index de Array debe ser intType: {type}");
                                            }

                                            codegen.AddQuad(Op.VER, exp, varArray.dimensionLow[counter], varArray.dimensionLow[counter] + varArray.dimensionSizes[counter] - 1);
                                            if (counter == 0)
                                            {
                                                codegen.AddQuad(Op.SET, exp, -1, reg);
                                            }
                                            else
                                            {
                                                constAddr = codegen.AddConstanteInt(varArray.dimensionSizes[counter].ToString());
                                                codegen.AddQuad(Op.MUL, reg, constAddr, reg);
                                                codegen.AddQuad(Op.ADD, reg, exp, reg);
                                            }


                                            ++counter; .)
        ']'
    {
        '['
                                        (.  if (counter == varArray.dimensionSizes.Length)
                                            {
                                                SemErr($"Invalid tamano(grande): {counter}");
                                            }
                                        .)
            Expresion<out type>
                                        (.  type = pilaType.Pop(); 
                                            exp = pilaOp.Pop();
                                            if (type != MyType.intType)
                                            {
                                                SemErr($"Index de Array debe ser intType: {type}");
                                            }

                                            codegen.AddQuad(Op.VER, exp, varArray.dimensionLow[counter], varArray.dimensionLow[counter] + varArray.dimensionSizes[counter] - 1);
                                            if (counter == 0)
                                            {
                                                codegen.AddQuad(Op.SET, exp, -1, reg);
                                            }
                                            else
                                            {
                                                constAddr = codegen.AddConstanteInt(varArray.dimensionSizes[counter].ToString());
                                                codegen.AddQuad(Op.MUL, reg, constAddr, reg);
                                                codegen.AddQuad(Op.ADD, reg, exp, reg);
                                            }


                                            ++counter; .)
        ']'
    }
                                        (.  if (counter != varArray.dimensionSizes.Length)
                                            {
                                                SemErr($"Invalid tamano(pequeno): {counter}");
                                            }

                                            constAddr = codegen.AddConstanteInt(varArray.ArrayConstant.ToString());
                                            codegen.AddQuad(Op.ADD, reg, constAddr, reg);

                                            int nextReg = codegen.NextRegister(MyType.intType);
                                            codegen.AddQuad(Op.VARADDRESS, varArray.address, -1, nextReg);
                                            codegen.AddQuad(Op.ADD, reg, nextReg, reg);

                                            refAddress = reg;
                                        .)
    .

/*Definicion de Expresiones queremos que las expresiones tengan orden de operaciones y las cosas que
aparecen primero son las cosas que tienen la menor prioridad en el orden de operaciones 
*/

/*Expresion para el or es la ultima y asi nos vamos este es el de menor prioridad y el de mas abajo es el de mas prioridad tener secciones
separadas nos ayuda a enforzar el orden de operaciones */
Expresion<out MyType type> =

/* 

    5 * 6 | 3 + 2 - 9 | 5 > 12

    Primero OR_Exp 
        5 * 6
        3 * 2 - 9
        5 > 12
    
    
    

 */

 /*El orden de estos esta basado en el orden de operaciones */
    OR_Exp<out type>
    {
        '|'                 (. pOper.Push(Op.OR); .)
        OR_Exp<out type>
                            (. CheckAndAddQuad(Op.OR); .)
    }
    .
/*or exp significa una expresion que no contiene un or and aparece aqui porque es lo siguiente que
debo checar */
OR_Exp<out MyType type> =
    AND_Exp<out type>
    {
        '&'                 (. pOper.Push(Op.AND); .)
        AND_Exp<out type>
                            (. CheckAndAddQuad(Op.AND); .)
    }
    .

AND_Exp<out MyType type> =  (. Op op; .) /*Es una declaracion de cuales no son iguales*/
    EQ_Exp<out type>
    [
        (
            "=="            (. op = Op.EQU; .)
            | "!="          (. op = Op.NEQ; .)
        )
                            (. pOper.Push(op); .)
        EQ_Exp<out type> 
                            (. CheckAndAddQuad(Op.EQU, Op.NEQ); .)
    ]
    .

EQ_Exp<out MyType type> =   (. Op op; .)
    CMP_Exp<out type>
    [
        (
            '>'             (. op = Op.GT; .)
            | ">="          (. op = Op.GTE; .)
            | '<'           (. op = Op.LT; .)
            | "<="          (. op = Op.LTE; .)
        )
                            (. pOper.Push(op); .)
        CMP_Exp<out type>
                            (. CheckAndAddQuad(Op.GT, Op.GTE, Op.LT, Op.LTE); .)
    ]
    .


CMP_Exp<out MyType type> = (. Op op; .)
    Term<out type>
    {
        (
            '+'             (. op = Op.ADD; .)
            | '-'           (. op = Op.SUB; .)
        )
                            (. pOper.Push(op); .)
        Term<out type>
                            (. CheckAndAddQuad(Op.ADD, Op.SUB); .)
    }
    .

/*Multiplicacion y Division */
Term<out MyType type> = (. Op op; .)
    Factor<out type>
    {
        (
            '*'         (. op = Op.MUL; .)
            | '/'       (. op = Op.DIV; .)
        )
                        (. pOper.Push(op); .)
        Factor<out type>
                        (. CheckAndAddQuad(Op.MUL, Op.DIV); .)
    }
    .

/*Esto significa un vez que los numeros se han separado ya individualmente pued eterminar como (5+6) como no lo podemos separas
aplica a factor */
Factor<out MyType type> (. type = MyType.undef; int address; .)
=
    (
        '('                  (. pOper.Push(Op.PAREN); .)
        Expresion<out type> 
        ')'                  (. if (pOper.Peek() != Op.PAREN)
                                {
                                    SemErr("Paren mismatch");
                                }
                                else
                                {
                                    pOper.Pop();
                                }
                                .)
    )
    | cte_i                         (.  type = MyType.intType; pilaType.Push(type); 
                                        address = codegen.AddConstanteInt(t.val);
                                        pilaOp.Push(address); .) /*un solo numero */

    | cte_f                         (.  type = MyType.floatType; pilaType.Push(type);
                                        address = codegen.AddConstanteFloat(t.val);
                                        pilaOp.Push(address); .) /*un solo float */

    | cte_c                         (.  type = MyType.charType; pilaType.Push(type);
                                        address = codegen.AddConstanteChar(t.val);
                                        pilaOp.Push(address); .) /*un solo char */

    | letrero                       (.  type = MyType.undef; pilaType.Push(type);
                                        address = codegen.AddConstanteLetrero(t.val);
                                        pilaOp.Push(address); .) /*un solo string */
    |
            /*esta es para cuando tienes funciones o variables tipo f(1+2) o id como b o a o i */
            id                              (. string idName = t.val; bool isFunc = false, isArray = false; .)
            [
                (
                    '('
                                                    (.  FuncRow row = codegen.GetFunction(idName);
                                                        if (!MyTypeUtil.IsValidReturnType(row.type))
                                                        {
                                                            SemErr($"Func {t.val} tiene tipo retorno invalido = {row.type}");
                                                        }
                                                        
                                                        codegen.AddQuad(Op.ERA, row.address, -1, -1);
                                                        isFunc = true;    .)
                        [ParametrosConValores<ref row>]

                                                    (.  codegen.AddQuad(Op.GOSUB, -1, -1, row.address); .)
                                                    (.  var reg = codegen.NextRegister(row.type);
                                                        string retName = null;
                                                        switch (row.type)
                                                        {
                                                            case MyType.intType:
                                                                retName = IntReturnFunc;
                                                                break;
                                                            case MyType.floatType:
                                                                retName = FloatReturnFunc;
                                                                break;
                                                            case MyType.charType:
                                                                retName = CharReturnFunc;
                                                                break;
                                                            default:
                                                                SemErr($"tipo invalido {row.type}");
                                                                break;
                                                        }

                                                        VarRow vRow = codegen.GetVar(retName);

                                                        codegen.AddQuad(Op.SET, vRow.address, -1, reg);
                                                        pilaType.Push(row.type);
                                                        pilaOp.Push(reg); .)
                    ')'
                )
                |
                (
                                                    (.  VarArray arrayVar = codegen.GetArray(idName);
                                                        isArray = true;
                                                        int derefAddr; .)

                    ArrayIndexing<ref arrayVar, out derefAddr>

                                                    (.  // TODO: need to deref 
                                                        int nextReg = codegen.NextRegister(arrayVar.type);
                                                        codegen.AddQuad(Op.DEREF, derefAddr, -1, nextReg);
                                                        pilaType.Push(arrayVar.type); pilaOp.Push(nextReg); .)
                )
            ]
                                        (. if (!isFunc && !isArray)
                                           {
                                               VarRow varRow = codegen.GetVar(idName);
                                               if (varRow.IsArray)
                                               {
                                                   SemErr($"{idName} es array, falta [ ] ");
                                                   return;
                                               }

                                               type = varRow.type;
                                               pilaType.Push(type); pilaOp.Push(varRow.address); 
                                           }
                                               .)
    .
    //| FuncionesEspeciales.
//PalabrasReservadas = "to" | "from" | "while" | "do" | "else" | "then" | "if" | "var" | "module" | tipo_retorno | "return" | "read" | "write".
//FuncionesEspeciales = "Line" | "Point" | "Circle" | "Arc" | "Penup" | "Pendown" | "Color" | "Size" | "Clear".
    
END MeMySelf.